<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Graph</title>
    <style>
        body {
            display: flex;
            height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
        }
        #matrix-container {
            flex: 1;
            padding: 20px;
            border-right: 1px solid #ccc;
            overflow: auto;
        }
        #matrix {
            border-collapse: collapse;
            margin: auto;
        }
        #matrix th, #matrix td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        #matrix th {
            background-color: #f2f2f2;
        }
        #analysis {
            margin-top: 30px;
            padding: 15px;
            background-color: #f0f8ff;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        #analysis h3 {
            margin-top: 0;
            color: #333;
        }
        #properties-table {
            width: 100%;
            border-collapse: collapse;
        }
        #properties-table td {
            padding: 8px;
            border-bottom: 1px solid #ddd;
        }
        #properties-table td.label {
            font-weight: bold;
            color: #555;
            width: 25%;
        }
        #properties-table td.value {
            width: 25%;
        }
        .property-value {
            padding: 3px 10px;
            border-radius: 3px;
            font-weight: bold;
        }
        .property-value.true {
            background-color: #90EE90;
            color: #006400;
        }
        .property-value.false {
            background-color: #FFB6C1;
            color: #8B0000;
        }
        .property-value.info {
            background-color: #E0E0E0;
            color: #333;
        }
        #additional-matrices {
            margin-top: 30px;
            padding: 15px;
            background-color: #f0f8ff;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        #additional-matrices h3 {
            margin-top: 0;
            color: #333;
        }
        .matrix-button {
            margin: 5px;
            padding: 8px 12px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        .matrix-button:hover {
            background-color: #45a049;
        }
        #result-matrix {
            margin-top: 15px;
            border-collapse: collapse;
            margin: auto;
        }
        #result-matrix th, #result-matrix td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        #result-matrix th {
            background-color: #f2f2f2;
        }
        #canvas-container {
            flex: 1;
            padding: 20px;
            position: relative;
            cursor: crosshair; /* Indicate it's clickable */
        }
        #canvas {
            width: 100%;
            height: 100%; /* Fill the container */
            position: relative;
            background-color: #f9f9f9;
            border: 1px solid #ccc;
        }
        #lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .point {
            position: absolute;
            width: 30px;
            height: 30px;
            background-color: red;
            border-radius: 50%;
            cursor: pointer;
            text-align: center;
            line-height: 30px;
            color: white;
            font-weight: bold;
        }
        .point:hover {
            background-color: darkred;
        }
        #click-area-title {
            font-size: 14px; /* Make it small */
            margin: 0;
            display: inline;
        }
        #reset-button {
            margin-left: 10px;
            padding: 5px 10px;
            background-color: #f44336;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        #reset-button:hover {
            background-color: #d32f2f;
        }
        #fill-diagonal-button {
            margin-left: 10px;
            padding: 5px 10px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        #fill-diagonal-button:hover {
            background-color: #1976D2;
        }
    </style>
</head>
<body>
    <div id="matrix-container">
        <h2>Adjacency Matrix</h2>
        <table id="matrix">
            <!-- The matrix will be generated dynamically -->
        </table>
        
        <div id="analysis">
            <h3>Graph Properties</h3>
            <table id="properties-table">
                <tr>
                    <td class="label">Number of vertices:</td>
                    <td class="value"><span class="property-value info" id="num-vertices">0</span></td>
                    <td class="label">Symmetric:</td>
                    <td class="value"><span class="property-value" id="is-symmetric">-</span></td>
                </tr>
                <tr>
                    <td class="label">Number of edges:</td>
                    <td class="value"><span class="property-value info" id="num-edges">0</span></td>
                    <td class="label">Antisymmetric:</td>
                    <td class="value"><span class="property-value" id="is-antisymmetric">-</span></td>
                </tr>
                <tr>
                    <td class="label">Strictly Complete:</td>
                    <td class="value"><span class="property-value" id="is-strictly-complete">-</span></td>
                    <td class="label">Transitive:</td>
                    <td class="value"><span class="property-value" id="is-transitive">-</span></td>
                </tr>
                <tr>
                    <td class="label">Soft Complete:</td>
                    <td class="value"><span class="property-value" id="is-soft-complete">-</span></td>
                    <td class="label">Complete Order:</td>
                    <td class="value"><span class="property-value" id="is-complete-order">-</span></td>
                </tr>
                <tr>
                    <td class="label">Reflexive:</td>
                    <td class="value"><span class="property-value" id="is-reflexive">-</span></td>
                    <td class="label">Complete Preorder:</td>
                    <td class="value"><span class="property-value" id="is-complete-preorder">-</span></td>
                </tr>
            </table>
        </div>

        <div id="additional-matrices">
            <h3>Additional Matrices</h3>
            <button class="matrix-button" id="strict-relation-btn">Show Strict Relation</button>
            <button class="matrix-button" id="indifference-relation-btn">Show Indifference Relation</button>
            <button class="matrix-button" id="topological-sort-soft-btn">Show Topological Sort Soft</button>
            <button class="matrix-button" id="topological-sort-strict-btn">Show Topological Sort Strict</button>
            <table id="result-matrix">
                <!-- Result matrix will be displayed here -->
            </table>
        </div>
    </div>
    <div id="canvas-container">
        <p id="click-area-title">Click Area (Add Points)</p>
        <button id="reset-button">Reset Graph</button>
        <button id="fill-diagonal-button">Fill Diagonal</button>
        <div id="canvas">
            <svg id="lines">
            </svg>
        </div>
    </div>

    <script>
        let points = [];
        let links = [];
        let selectedPoint = null;
        let tempLine = null;

        const canvas = document.getElementById('canvas');
        const canvasContainer = document.getElementById('canvas-container');
        const linesSvg = document.getElementById('lines');
        const matrixTable = document.getElementById('matrix');
        const resultMatrixTable = document.getElementById('result-matrix');
        const resetButton = document.getElementById('reset-button');
        const fillDiagonalButton = document.getElementById('fill-diagonal-button');
        const strictRelationBtn = document.getElementById('strict-relation-btn');
        const indifferenceRelationBtn = document.getElementById('indifference-relation-btn');
        const topologicalSortSoftBtn = document.getElementById('topological-sort-soft-btn');
        const topologicalSortStrictBtn = document.getElementById('topological-sort-strict-btn');

        // Load matrix and points on startup
        async function loadData() {
            const response = await fetch('/matrix');
            const data = await response.json();
            points = data.points;
            links = data.links;
            updateMatrix(data.matrix);
            updateAnalysis(data.analysis);
            updateCanvas();
            updateLinks();
        }

        function updateAnalysis(analysis) {
            document.getElementById('num-vertices').textContent = analysis.num_vertices;
            document.getElementById('num-edges').textContent = analysis.num_edges;
            
            const boolProps = ['is-strictly-complete', 'is-soft-complete', 'is-reflexive', 'is-symmetric', 'is-antisymmetric', 'is-transitive', 'is-complete-order', 'is-complete-preorder'];
            boolProps.forEach(prop => {
                const elem = document.getElementById(prop);
                const key = prop.replace(/-/g, '_');
                const value = analysis[key];
                elem.textContent = value ? 'Yes' : 'No';
                elem.className = 'property-value ' + (value ? 'true' : 'false');
            });
        }

        canvasContainer.addEventListener('click', async function(event) {
            // Ignore if clicking on point or button
            if (event.target.classList.contains('point') || event.target.tagName === 'BUTTON') return;
            
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            // Check if the click is too close to an existing point (forbidden hitbox: 2x size, so radius 30px)
            const forbiddenRadius = 30; // 15px point radius * 2
            const tooClose = points.some(point => {
                const dx = x - point.x;
                const dy = y - point.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < forbiddenRadius;
            });
            if (tooClose) return; // Don't add point if too close

            // Send to server
            const response = await fetch('/add_point', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ x: x, y: y })
            });
            const result = await response.json();

            // Reload data
            await loadData();
        });

        canvas.addEventListener('mousemove', function(event) {
            if (selectedPoint) {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                updateTempLine(x, y);
            }
        });

        resetButton.addEventListener('click', async function() {
            await fetch('/reset', { method: 'POST' });
            await loadData();
        });

        fillDiagonalButton.addEventListener('click', async function() {
            await fetch('/fill_diagonal', { method: 'POST' });
            await loadData();
        });

        strictRelationBtn.addEventListener('click', async function() {
            const response = await fetch('/strict_relation');
            const data = await response.json();
            displayMatrix(data.matrix, 'Strict Relation');
        });

        indifferenceRelationBtn.addEventListener('click', async function() {
            const response = await fetch('/indifference_relation');
            const data = await response.json();
            displayMatrix(data.matrix, 'Indifference Relation');
        });

        topologicalSortSoftBtn.addEventListener('click', async function() {
            const response = await fetch('/topological_sort_soft');
            const data = await response.json();
            displayList(data.sort, 'Topological Sort Soft');
        });

        topologicalSortStrictBtn.addEventListener('click', async function() {
            const response = await fetch('/topological_sort_strict');
            const data = await response.json();
            displayList(data.sort, 'Topological Sort Strict');
        });

        function displayMatrix(matrixData, title) {
            // Clear the table
            resultMatrixTable.innerHTML = '';

            // Add title as a row
            const titleRow = document.createElement('tr');
            const titleCell = document.createElement('th');
            titleCell.colSpan = points.length + 1;
            titleCell.textContent = title;
            titleRow.appendChild(titleCell);
            resultMatrixTable.appendChild(titleRow);

            // Add header
            const headerRow = document.createElement('tr');
            headerRow.appendChild(document.createElement('th')); // Empty corner
            for (let i = 0; i < points.length; i++) {
                const th = document.createElement('th');
                th.textContent = points[i].id;
                headerRow.appendChild(th);
            }
            resultMatrixTable.appendChild(headerRow);

            // Add rows
            for (let i = 0; i < points.length; i++) {
                const row = document.createElement('tr');
                const th = document.createElement('th');
                th.textContent = points[i].id;
                row.appendChild(th);

                for (let j = 0; j < points.length; j++) {
                    const cell = document.createElement('td');
                    cell.textContent = matrixData[i][j];
                    row.appendChild(cell);
                }
                resultMatrixTable.appendChild(row);
            }
        }

        function displayList(sortData, title) {
            // Clear the table
            resultMatrixTable.innerHTML = '';

            // Add title
            const titleRow = document.createElement('tr');
            const titleCell = document.createElement('th');
            titleCell.textContent = title;
            titleRow.appendChild(titleCell);
            resultMatrixTable.appendChild(titleRow);

            // Add the list as a single row
            const row = document.createElement('tr');
            for (let i = 0; i < sortData.length; i++) {
                const cell = document.createElement('td');
                cell.textContent = points[sortData[i]].id;
                row.appendChild(cell);
            }
            resultMatrixTable.appendChild(row);
        }

        function updateMatrix(matrixData) {
            // Clear the matrix
            matrixTable.innerHTML = '';

            // Add header
            const headerRow = document.createElement('tr');
            headerRow.appendChild(document.createElement('th')); // Empty corner
            for (let i = 0; i < points.length; i++) {
                const th = document.createElement('th');
                th.textContent = points[i].id;
                headerRow.appendChild(th);
            }
            matrixTable.appendChild(headerRow);

            // Add rows
            for (let i = 0; i < points.length; i++) {
                const row = document.createElement('tr');
                const th = document.createElement('th');
                th.textContent = points[i].id;
                row.appendChild(th);

                for (let j = 0; j < points.length; j++) {
                    const cell = document.createElement('td');
                    cell.textContent = matrixData[i][j];
                    row.appendChild(cell);
                }
                matrixTable.appendChild(row);
            }
        }

        function updateCanvas() {
            // Clear canvas except SVG
            const svg = canvas.querySelector('svg');
            canvas.innerHTML = '';
            canvas.appendChild(svg);

            // Add points
            points.forEach(point => {
                if (!point.color) point.color = '#ff0000'; // Default color for old points
                const pointDiv = document.createElement('div');
                pointDiv.className = 'point';
                pointDiv.style.left = (point.x - 15) + 'px'; // Center (30/2 = 15)
                pointDiv.style.top = (point.y - 15) + 'px';
                pointDiv.textContent = point.id;
                pointDiv.style.backgroundColor = point.color;
                pointDiv.addEventListener('click', async function(e) {
                    e.stopPropagation();
                    if (selectedPoint === null) {
                        selectedPoint = point.id;
                        startTempLine(point.x, point.y, point.color);
                    } else if (selectedPoint !== point.id) {
                        // Create link
                        await fetch('/add_link', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ from: selectedPoint, to: point.id })
                        });
                        selectedPoint = null;
                        removeTempLine();
                        await loadData();
                    } else {
                        // Click on same point: create a self-loop
                        await fetch('/add_link', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ from: selectedPoint, to: point.id })
                        });
                        selectedPoint = null;
                        removeTempLine();
                        await loadData();
                    }
                });
                canvas.appendChild(pointDiv);
            });
        }

        function updateLinks() {
            // Clear lines except temp
            const lines = linesSvg.querySelectorAll('line:not(.temp), polygon:not(.temp), path:not(.temp)');
            lines.forEach(l => l.remove());

            links.forEach(link => {
                const fromPoint = points.find(p => p.id === link.from);
                const toPoint = points.find(p => p.id === link.to);
                if (fromPoint && toPoint) {
                    if (link.from === link.to) {
                        // Self-loop: draw an arc
                        const radius = 20;
                        const cx = fromPoint.x;
                        const cy = fromPoint.y - radius;
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        path.setAttribute('d', `M ${cx - radius} ${cy} A ${radius} ${radius} 0 1 1 ${cx + radius} ${cy}`);
                        path.setAttribute('stroke', fromPoint.color);
                        path.setAttribute('stroke-width', '2');
                        path.setAttribute('fill', 'none');
                        path.setAttribute('opacity', '0.6');
                        linesSvg.appendChild(path);

                        // Arrow for self-loop
                        const arrowX = cx + radius / 4;
                        const arrowY = cy;
                        const angle = Math.PI; // To the left
                        const arrowLength = 15;
                        const arrowWidth = 7;
                        const p1x = arrowX - arrowLength * Math.cos(angle) - arrowWidth * Math.sin(angle);
                        const p1y = arrowY - arrowLength * Math.sin(angle) + arrowWidth * Math.cos(angle);
                        const p2x = arrowX;
                        const p2y = arrowY;
                        const p3x = arrowX - arrowLength * Math.cos(angle) + arrowWidth * Math.sin(angle);
                        const p3y = arrowY - arrowLength * Math.sin(angle) - arrowWidth * Math.cos(angle);

                        const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        arrow.setAttribute('points', `${p1x},${p1y} ${p2x},${p2y} ${p3x},${p3y}`);
                        arrow.setAttribute('fill', fromPoint.color);
                        arrow.setAttribute('opacity', '0.6');
                        linesSvg.appendChild(arrow);
                    } else {
                        // Normal line
                        // Calculate coordinates to stop the line before the destination point
                        const dx = toPoint.x - fromPoint.x;
                        const dy = toPoint.y - fromPoint.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const offset = 20; // Distance before point
                        const ratio = (dist - offset) / dist;
                        const x2 = fromPoint.x + dx * ratio;
                        const y2 = fromPoint.y + dy * ratio;

                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', fromPoint.x);
                        line.setAttribute('y1', fromPoint.y);
                        line.setAttribute('x2', x2);
                        line.setAttribute('y2', y2);
                        line.setAttribute('stroke', fromPoint.color);
                        line.setAttribute('stroke-width', '2');
                        line.setAttribute('opacity', '0.6');
                        linesSvg.appendChild(line);

                        // Add arrow (triangle)
                        const angle = Math.atan2(dy, dx);
                        const arrowLength = 10;
                        const arrowWidth = 7;
                        const arrowX = x2;
                        const arrowY = y2;
                        const p1x = arrowX - arrowLength * Math.cos(angle) - arrowWidth * Math.sin(angle);
                        const p1y = arrowY - arrowLength * Math.sin(angle) + arrowWidth * Math.cos(angle);
                        const p2x = arrowX;
                        const p2y = arrowY;
                        const p3x = arrowX - arrowLength * Math.cos(angle) + arrowWidth * Math.sin(angle);
                        const p3y = arrowY - arrowLength * Math.sin(angle) - arrowWidth * Math.cos(angle);

                        const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        arrow.setAttribute('points', `${p1x},${p1y} ${p2x},${p2y} ${p3x},${p3y}`);
                        arrow.setAttribute('fill', fromPoint.color);
                        arrow.setAttribute('opacity', '0.6');
                        linesSvg.appendChild(arrow);
                    }
                }
            });
        }

        let tempArrow = null;

        function startTempLine(x, y, color) {
            tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            tempLine.classList.add('temp');
            tempLine.setAttribute('x1', x);
            tempLine.setAttribute('y1', y);
            tempLine.setAttribute('x2', x);
            tempLine.setAttribute('y2', y);
            tempLine.setAttribute('stroke', color);
            tempLine.setAttribute('stroke-width', '2');
            tempLine.setAttribute('stroke-dasharray', '5,5');
            tempLine.setAttribute('opacity', '0.6');
            tempLine.setAttribute('color', color);
            linesSvg.appendChild(tempLine);

            tempArrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            tempArrow.classList.add('temp');
            tempArrow.setAttribute('points', '0,0 0,0 0,0');
            tempArrow.setAttribute('fill', color);
            tempArrow.setAttribute('opacity', '0.6');
            linesSvg.appendChild(tempArrow);
        }

        function updateTempLine(x, y) {
            if (tempLine && tempArrow) {
                const x1 = parseFloat(tempLine.getAttribute('x1'));
                const y1 = parseFloat(tempLine.getAttribute('y1'));
                const dx = x - x1;
                const dy = y - y1;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const offset = 20;
                const ratio = (dist - offset) / dist;
                const x2 = x1 + dx * ratio;
                const y2 = y1 + dy * ratio;

                tempLine.setAttribute('x2', x2);
                tempLine.setAttribute('y2', y2);

                // Calculate arrow
                const angle = Math.atan2(dy, dx);
                const arrowLength = 10;
                const arrowWidth = 7;
                const arrowX = x2;
                const arrowY = y2;
                const p1x = arrowX - arrowLength * Math.cos(angle) - arrowWidth * Math.sin(angle);
                const p1y = arrowY - arrowLength * Math.sin(angle) + arrowWidth * Math.cos(angle);
                const p2x = arrowX;
                const p2y = arrowY;
                const p3x = arrowX - arrowLength * Math.cos(angle) + arrowWidth * Math.sin(angle);
                const p3y = arrowY - arrowLength * Math.sin(angle) - arrowWidth * Math.cos(angle);

                tempArrow.setAttribute('points', `${p1x},${p1y} ${p2x},${p2y} ${p3x},${p3y}`);
            }
        }

        function removeTempLine() {
            if (tempLine) {
                tempLine.remove();
                tempLine = null;
            }
            if (tempArrow) {
                tempArrow.remove();
                tempArrow = null;
            }
        }

        // Load on startup
        loadData();
    </script>
</body>
</html>