<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Graph</title>
    <style>
        body {
            display: flex;
            height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
        }
        #matrix-container {
            flex: 1;
            padding: 20px;
            border-right: 1px solid #ccc;
            overflow: auto;
        }
        #matrix {
            border-collapse: collapse;
            margin: auto;
        }
        #matrix th, #matrix td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        #matrix th {
            background-color: #f2f2f2;
        }
        #analysis {
            margin-top: 30px;
            padding: 15px;
            background-color: #f0f8ff;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        #analysis h3 {
            margin-top: 0;
            color: #333;
        }
        .property {
            margin: 8px 0;
            padding: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .property-label {
            font-weight: bold;
            color: #555;
        }
        .property-value {
            padding: 3px 10px;
            border-radius: 3px;
            font-weight: bold;
        }
        .property-value.true {
            background-color: #90EE90;
            color: #006400;
        }
        .property-value.false {
            background-color: #FFB6C1;
            color: #8B0000;
        }
        .property-value.info {
            background-color: #E0E0E0;
            color: #333;
        }
        #canvas-container {
            flex: 1;
            padding: 20px;
            position: relative;
        }
        #canvas {
            width: 100%;
            height: 400px;
            border: 1px solid #ccc;
            position: relative;
            background-color: #f9f9f9;
        }
        #lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .point {
            position: absolute;
            width: 30px;
            height: 30px;
            background-color: red;
            border-radius: 50%;
            cursor: pointer;
            text-align: center;
            line-height: 30px;
            color: white;
            font-weight: bold;
        }
        .point:hover {
            background-color: darkred;
        }
    </style>
</head>
<body>
    <div id="matrix-container">
        <h2>Adjacency Matrix</h2>
        <table id="matrix">
            <!-- The matrix will be generated dynamically -->
        </table>
        
        <div id="analysis">
            <h3>Graph Properties</h3>
            <div class="property">
                <span class="property-label">Number of vertices:</span>
                <span class="property-value info" id="num-vertices">0</span>
            </div>
            <div class="property">
                <span class="property-label">Number of edges:</span>
                <span class="property-value info" id="num-edges">0</span>
            </div>
            <div class="property">
                <span class="property-label">Complete:</span>
                <span class="property-value" id="is-complete">-</span>
            </div>
            <div class="property">
                <span class="property-label">Reflexive:</span>
                <span class="property-value" id="is-reflexive">-</span>
            </div>
            <div class="property">
                <span class="property-label">Symmetric:</span>
                <span class="property-value" id="is-symmetric">-</span>
            </div>
            <div class="property">
                <span class="property-label">Antisymmetric:</span>
                <span class="property-value" id="is-antisymmetric">-</span>
            </div>
            <div class="property">
                <span class="property-label">Transitive:</span>
                <span class="property-value" id="is-transitive">-</span>
            </div>
        </div>
    </div>
    <div id="canvas-container">
        <h2>Click Area (Add Points)</h2>
        <div id="canvas">
            <svg id="lines">
            </svg>
        </div>
    </div>

    <script>
        let points = [];
        let links = [];
        let selectedPoint = null;
        let tempLine = null;

        const canvas = document.getElementById('canvas');
        const linesSvg = document.getElementById('lines');
        const matrixTable = document.getElementById('matrix');

        // Load matrix and points on startup
        async function loadData() {
            const response = await fetch('/matrix');
            const data = await response.json();
            points = data.points;
            links = data.links;
            updateMatrix(data.matrix);
            updateAnalysis(data.analysis);
            updateCanvas();
            updateLinks();
        }

        function updateAnalysis(analysis) {
            document.getElementById('num-vertices').textContent = analysis.num_vertices;
            document.getElementById('num-edges').textContent = analysis.num_edges;
            
            const boolProps = ['is-complete', 'is-reflexive', 'is-symmetric', 'is-antisymmetric', 'is-transitive'];
            boolProps.forEach(prop => {
                const elem = document.getElementById(prop);
                const key = prop.replace(/-/g, '_');
                const value = analysis[key];
                elem.textContent = value ? 'Yes' : 'No';
                elem.className = 'property-value ' + (value ? 'true' : 'false');
            });
        }

        canvas.addEventListener('click', async function(event) {
            if (event.target.classList.contains('point')) return; // Ignore if clicking on point
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            // Send to server
            const response = await fetch('/add_point', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ x: x, y: y })
            });
            const result = await response.json();

            // Reload data
            await loadData();
        });

        canvas.addEventListener('mousemove', function(event) {
            if (selectedPoint) {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                updateTempLine(x, y);
            }
        });

        function updateMatrix(matrixData) {
            // Clear the matrix
            matrixTable.innerHTML = '';

            // Add header
            const headerRow = document.createElement('tr');
            headerRow.appendChild(document.createElement('th')); // Empty corner
            for (let i = 0; i < points.length; i++) {
                const th = document.createElement('th');
                th.textContent = points[i].id;
                headerRow.appendChild(th);
            }
            matrixTable.appendChild(headerRow);

            // Add rows
            for (let i = 0; i < points.length; i++) {
                const row = document.createElement('tr');
                const th = document.createElement('th');
                th.textContent = points[i].id;
                row.appendChild(th);

                for (let j = 0; j < points.length; j++) {
                    const cell = document.createElement('td');
                    cell.textContent = matrixData[i][j];
                    row.appendChild(cell);
                }
                matrixTable.appendChild(row);
            }
        }

        function updateCanvas() {
            // Clear canvas except SVG
            const svg = canvas.querySelector('svg');
            canvas.innerHTML = '';
            canvas.appendChild(svg);

            // Add points
            points.forEach(point => {
                if (!point.color) point.color = '#ff0000'; // Default color for old points
                const pointDiv = document.createElement('div');
                pointDiv.className = 'point';
                pointDiv.style.left = (point.x - 15) + 'px'; // Center (30/2 = 15)
                pointDiv.style.top = (point.y - 15) + 'px';
                pointDiv.textContent = point.id;
                pointDiv.style.backgroundColor = point.color;
                pointDiv.addEventListener('click', async function(e) {
                    e.stopPropagation();
                    if (selectedPoint === null) {
                        selectedPoint = point.id;
                        startTempLine(point.x, point.y, point.color);
                    } else if (selectedPoint !== point.id) {
                        // Create link
                        await fetch('/add_link', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ from: selectedPoint, to: point.id })
                        });
                        selectedPoint = null;
                        removeTempLine();
                        await loadData();
                    } else {
                        // Click on same point: create a self-loop
                        await fetch('/add_link', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ from: selectedPoint, to: point.id })
                        });
                        selectedPoint = null;
                        removeTempLine();
                        await loadData();
                    }
                });
                canvas.appendChild(pointDiv);
            });
        }

        function updateLinks() {
            // Clear lines except temp
            const lines = linesSvg.querySelectorAll('line:not(.temp), polygon:not(.temp), path:not(.temp)');
            lines.forEach(l => l.remove());

            links.forEach(link => {
                const fromPoint = points.find(p => p.id === link.from);
                const toPoint = points.find(p => p.id === link.to);
                if (fromPoint && toPoint) {
                    if (link.from === link.to) {
                        // Self-loop: draw an arc
                        const radius = 20;
                        const cx = fromPoint.x;
                        const cy = fromPoint.y - radius;
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        path.setAttribute('d', `M ${cx - radius} ${cy} A ${radius} ${radius} 0 1 1 ${cx + radius} ${cy}`);
                        path.setAttribute('stroke', fromPoint.color);
                        path.setAttribute('stroke-width', '2');
                        path.setAttribute('fill', 'none');
                        path.setAttribute('opacity', '0.6');
                        linesSvg.appendChild(path);

                        // Arrow for self-loop
                        const arrowX = cx + radius / 4;
                        const arrowY = cy;
                        const angle = Math.PI; // To the left
                        const arrowLength = 15;
                        const arrowWidth = 7;
                        const p1x = arrowX - arrowLength * Math.cos(angle) - arrowWidth * Math.sin(angle);
                        const p1y = arrowY - arrowLength * Math.sin(angle) + arrowWidth * Math.cos(angle);
                        const p2x = arrowX;
                        const p2y = arrowY;
                        const p3x = arrowX - arrowLength * Math.cos(angle) + arrowWidth * Math.sin(angle);
                        const p3y = arrowY - arrowLength * Math.sin(angle) - arrowWidth * Math.cos(angle);

                        const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        arrow.setAttribute('points', `${p1x},${p1y} ${p2x},${p2y} ${p3x},${p3y}`);
                        arrow.setAttribute('fill', fromPoint.color);
                        arrow.setAttribute('opacity', '0.6');
                        linesSvg.appendChild(arrow);
                    } else {
                        // Normal line
                        // Calculate coordinates to stop the line before the destination point
                        const dx = toPoint.x - fromPoint.x;
                        const dy = toPoint.y - fromPoint.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const offset = 20; // Distance before point
                        const ratio = (dist - offset) / dist;
                        const x2 = fromPoint.x + dx * ratio;
                        const y2 = fromPoint.y + dy * ratio;

                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', fromPoint.x);
                        line.setAttribute('y1', fromPoint.y);
                        line.setAttribute('x2', x2);
                        line.setAttribute('y2', y2);
                        line.setAttribute('stroke', fromPoint.color);
                        line.setAttribute('stroke-width', '2');
                        line.setAttribute('opacity', '0.6');
                        linesSvg.appendChild(line);

                        // Add arrow (triangle)
                        const angle = Math.atan2(dy, dx);
                        const arrowLength = 10;
                        const arrowWidth = 7;
                        const arrowX = x2;
                        const arrowY = y2;
                        const p1x = arrowX - arrowLength * Math.cos(angle) - arrowWidth * Math.sin(angle);
                        const p1y = arrowY - arrowLength * Math.sin(angle) + arrowWidth * Math.cos(angle);
                        const p2x = arrowX;
                        const p2y = arrowY;
                        const p3x = arrowX - arrowLength * Math.cos(angle) + arrowWidth * Math.sin(angle);
                        const p3y = arrowY - arrowLength * Math.sin(angle) - arrowWidth * Math.cos(angle);

                        const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        arrow.setAttribute('points', `${p1x},${p1y} ${p2x},${p2y} ${p3x},${p3y}`);
                        arrow.setAttribute('fill', fromPoint.color);
                        arrow.setAttribute('opacity', '0.6');
                        linesSvg.appendChild(arrow);
                    }
                }
            });
        }

        let tempArrow = null;

        function startTempLine(x, y, color) {
            tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            tempLine.classList.add('temp');
            tempLine.setAttribute('x1', x);
            tempLine.setAttribute('y1', y);
            tempLine.setAttribute('x2', x);
            tempLine.setAttribute('y2', y);
            tempLine.setAttribute('stroke', color);
            tempLine.setAttribute('stroke-width', '2');
            tempLine.setAttribute('stroke-dasharray', '5,5');
            tempLine.setAttribute('opacity', '0.6');
            tempLine.setAttribute('color', color);
            linesSvg.appendChild(tempLine);

            tempArrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            tempArrow.classList.add('temp');
            tempArrow.setAttribute('points', '0,0 0,0 0,0');
            tempArrow.setAttribute('fill', color);
            tempArrow.setAttribute('opacity', '0.6');
            linesSvg.appendChild(tempArrow);
        }

        function updateTempLine(x, y) {
            if (tempLine && tempArrow) {
                const x1 = parseFloat(tempLine.getAttribute('x1'));
                const y1 = parseFloat(tempLine.getAttribute('y1'));
                const dx = x - x1;
                const dy = y - y1;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const offset = 20;
                const ratio = (dist - offset) / dist;
                const x2 = x1 + dx * ratio;
                const y2 = y1 + dy * ratio;

                tempLine.setAttribute('x2', x2);
                tempLine.setAttribute('y2', y2);

                // Calculate arrow
                const angle = Math.atan2(dy, dx);
                const arrowLength = 10;
                const arrowWidth = 7;
                const arrowX = x2;
                const arrowY = y2;
                const p1x = arrowX - arrowLength * Math.cos(angle) - arrowWidth * Math.sin(angle);
                const p1y = arrowY - arrowLength * Math.sin(angle) + arrowWidth * Math.cos(angle);
                const p2x = arrowX;
                const p2y = arrowY;
                const p3x = arrowX - arrowLength * Math.cos(angle) + arrowWidth * Math.sin(angle);
                const p3y = arrowY - arrowLength * Math.sin(angle) - arrowWidth * Math.cos(angle);

                tempArrow.setAttribute('points', `${p1x},${p1y} ${p2x},${p2y} ${p3x},${p3y}`);
            }
        }

        function removeTempLine() {
            if (tempLine) {
                tempLine.remove();
                tempLine = null;
            }
            if (tempArrow) {
                tempArrow.remove();
                tempArrow = null;
            }
        }

        // Load on startup
        loadData();
    </script>
</body>
</html>